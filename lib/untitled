


var q = db.event({
    a: related.variable('event.a')
}).prepare();


var query = q({
    'event.a': 23 
}).findd();


q.getSQL();


query.host(aster').find();


// connection pool
the pool analyzes how many prepared stements vs non preparedd statements are executedd, it 
tries tpo dostribute the load on the available connections and prepares each statement on 
the correspondding connection.

the pool neeed to know if a onnection is getting dirty by the query passed to it.  connections
tht are getting dirty must not be recycled!


// compiled query
[
    {
          type: 'entity'
        , entityName: 'event'
        , columns: [
            {
                  type: 'column'
                , columnName: 'id_tenant'
                , filters: [
                    {
                          type: 'filter'
                        , kind: 'query'
                        , operator: 'equal'
                        , value: {
                              type: 'query'
                            , select: ['id']
                            , schema: 'eventbooster'
                            , entityName: 'event'
                            , alias: 'childEvent'
                            , filter: []
                            , having: []
                            , order: [{
                                  type: 'order'
                                , desc: false
                                , priority: 3
                                , array: null
                                , columnName: ''
                            }]
                            , group: []
                        }
                    }, {
                          type: 'filter'
                        , kind: 'scalar'
                        , operator: 'gte'
                        , value: {
                                type: 'variable'
                              , getValue()
                        }
                    }, {
                          type: 'orFilter'
                        , values: []
                    }
                ]
            }
        ]
    }
]



// related
{
      select(alias).average('event.id')
    , filter(event.id).equals(related.variable('hui'))
    , and()
    , or()

    , createSchema()
}


// db 
{
      createTransaction()
    , createEntity()

}



// entity
{    
      columns: {}
    , references: {}
    , belongsTo: {}
    , mapsTo: {}

    , warnings: []

    , schema: ''
    , database: ''
    , schemaAlias: ''
    , entitiy: ''
    , alias: '' 
}



// querybuilder
{
    query: {
          select: ['id']
        , schema: 'eventbooster'
        , entityName: 'event'
        , alias: 'childEvent'
        , filter: []
        , having: []
        , order: [{
              type: 'order'
            , desc: false
            , priority: 3
            , array: null
            , columnName: ''
        }]
        , group: []
    }

    , localQuery: {
          select: ['id']
        , schema: 'eventbooster'
        , entityName: 'event'
        , alias: 'childEvent'
        , filter: []
        , having: []
        , join: {
            eventData: {
                  type: 'left'
                , join: {}
            }
        }
        , order: [{
              type: 'order'
            , desc: false
            , priority: 3
            , array: null
            , columnName: ''
        }]
        , group: []
        , addFilter(entity, property, filter)
        , addSelection(selection)
        , addGroup()
        , addHaving()
        , addOrder()

    }

    , children: []


    , columns: {}
    , references: {}
    , belongsTo: {}
    , mapsTo: {}

    , warnings: []

    , schema: ''
    , database: ''
    , schemaAlias: ''
    , entitiy: ''
    , alias: '' 


    , filter()
    , filterBase()
    , select(column|alias).sum('event.id')
    , selectBase()
    , order()
    , orderBase()
    , limit()
    , limitBase()


    , debug()


    , isBase()
    , hasParent()
    , hasChildren()

    , parentQuery()
    , childQueries()


    , has()
    , join()
    , leftJoin()
    , get()
    , fetch()


    , find()
    , findOne()
    , update()
    , delete()


    , extensions: {}
    , eventListeners: {}
}





// model
{
    , $info: {
          schema: ''
        , database: ''
        , schemaAlias: ''
        , entitiy: ''
        , alias: '' 


        , columns: {}
        , references: {}
        , belongsTo: {}
        , mapsTo: {}

        , warnings: []
    }

    , $cache: {} // the data retreived from the db
    , $selection: [] // the coulmns selected when loadin data from the db
    , $query: {} // the query that loaded this model


    , prop: ''


    , clone()
    , save()
    , delete()
    , reload()
    , clear()
    , discardChanges()


    , isDirty()
    , isNew()
    , isCloned()

    , copy()
    , reassign()
}



// set
{
      push()
    , pop()
    , shift()
    , unshift()
    , splice()

    , query: {}

    , schema: ''
    , database: ''
    , schemaAlias: ''
    , entitiy: ''
    , alias: '' 


    , columns: {}
    , references: {}
    , belongsTo: {}
    , mapsTo: {}

    , warnings: []
}




// async events
{
      on('evt', fn)
    , off()
    , emit().then(fn(abort)).catch()
    , listener()
}