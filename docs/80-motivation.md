# Motivation

So, why to create a new ORM if there are already a bunch of good ones? That's a 
good question, but truly one that has also a very good answer. 

Each of the existsting ORMs has its own unique features and serve their users very well. 
Some of them have a really big and great community which makes developing using
them a lot easier. But all of them follow more or less the same principles. 

For example, a software engineer has to write models that represent the tables 
in the databsase. Maybe one or the other ORM provides some tools for generating 
a scaffolding for those models which makes writing them much easier. 

Another thing that most ORMs do is providing a SQL like interface for filtering
and fething data from the database. 

There is nothing wrong with that, but the authors of Related think it should be 
much easier to work with an ORM. Why should one write models if all the information
needed for atomatically genreating models is already available in the database?
Why has the user to think about the logic behind SQL if most of the CRUD and Query
operations can be easily generated by the ORM? Why should a user design its database
around some ORM induced limitations (speaking of you bookshelf)?

So, what's the main thing that differentiates Related from the other ORMs? It
does the annoying work for you, leaves you every freedom and gets you up and 
running within one minute, even for a database with thousands of tables.

And what's the catch? Your database should to be properly normalized and your tables
need primary keys. That's all! The better you normalized your database design, the
better Related can work with it.

When related is initialized, it connects to the databse and queries all the 
details for each and every table in your database. Using that information it 
on the fly builds models and an extensive querybuilder and filtering interface.
You are still able to write your custom models, but it is only an option. 

This makes it also convenient to implement extensions that work properly 
across all models. We got already and handful of very usable of them.  



And here some of the key features:

- Automatic Model & Query Builder setup
- Cluster support: Read Replicas and Hot Standbys with automatic failover
- Transactions
- Migrations
- Reporting
- Raw SQL Queries(if you really need to)
- Advanced and compley loading of nested entites
- 


Sounds nice? It is! Give it a try!  